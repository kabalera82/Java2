/*
========================================================================================================================
HILOS EN JAVA â€“ ESQUEMA RESUMEN (DOCENTE / DAM)
========================================================================================================================

1. Â¿QUÃ‰ ES UN HILO?
------------------------------------------------------------------------------------------------------------------------
- Un hilo (Thread) es un camino de ejecuciÃ³n dentro de un mismo proceso.
- Un proceso puede tener varios hilos ejecutÃ¡ndose (a la vez o intercalados).
- Los hilos de un proceso comparten memoria y recursos (objetos, ficheros, BDâ€¦).
- El hilo principal es el que ejecuta el mÃ©todo main(String[] args).

2. USOS DE LOS HILOS Y CUÃNDO USAR CADA FORMA

ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥
ğŸ”¥ 1ï¸âƒ£ CUÃNDO USAR implements Runnable (LA OPCIÃ“N CORRECTA EL 95% DE LAS VECES)
ğŸ”¥   ğŸ‘‰ Cuando tu clase ya hereda de otra (porque Java solo permite UNA herencia).
ğŸ”¥   ğŸ‘‰ Cuando quieres separar la lÃ³gica del hilo de la gestiÃ³n del hilo.
ğŸ”¥   ğŸ‘‰ Cuando quieres reutilizar el mismo Runnable en varios Threads.
ğŸ”¥   ğŸ‘‰ Cuando sigues buenas prÃ¡cticas de Java (lo profesional).
ğŸ”¥
ğŸ”¥ 2ï¸âƒ£ CUÃNDO USAR extends Thread
ğŸ”¥
ğŸ”¥  ğŸ‘‰ Solo cuando NECESITAS modificar el propio comportamiento del hilo.
ğŸ”¥  ğŸ‘‰ Cuando quieres crear una subclase REAL de Thread.
ğŸ”¥  ğŸ‘‰ Cuando quieres aÃ±adir funcionalidad al hilo mismo, no a la tarea.
ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥


2.1 Usos generales de los hilos
- Ejecutar tareas en paralelo:
  - Descargar archivos mientras la UI responde.
  - Consultar BBDD sin bloquear la aplicaciÃ³n.
  - Procesar muchas peticiones en un servidor.
- Aprovechar varios nÃºcleos de CPU.
- Mantener la aplicaciÃ³n fluida (trabajo pesado en segundo plano).

2.2 CuÃ¡ndo usar cada â€œformaâ€ de trabajar con hilos
- extends Thread
  - Para ejemplos simples y prÃ¡cticas introductorias.
  - Cuando solo necesitas ver cÃ³mo arranca un hilo y quÃ© hace run().
  - No se recomienda en proyectos grandes.

- implements Runnable (o lambda)
  - Tareas en segundo plano que NO devuelven un valor.
  - Quieres separar la lÃ³gica de la tarea del mecanismo de ejecuciÃ³n.
  - Recomendado para cÃ³digo normal: Runnable + Thread o Runnable + ExecutorService.

- Callable<V> + Future<V>
  - Tareas en segundo plano que SÃ deben devolver un resultado.
  - Consultas a BBDD, cÃ¡lculos pesados, llamadas a APIs donde necesitas la respuesta.
  - Permite saber si la tarea terminÃ³ y recoger el resultado mÃ¡s tarde.

- ExecutorService (pools de hilos)
  - Cuando tienes muchas tareas o una app â€œseriaâ€ (servidores, servicios, procesos largos).
  - En vez de crear hilos uno a uno, envÃ­as tareas a un pool que los gestiona.
  - Forma profesional de gestionar concurrencia en Java.

3. CÃ“MO USAR LOS HILOS (PATRONES BÃSICOS)
------------------------------------------------------------------------------------------------------------------------

// 3.1. Extender Thread (forma bÃ¡sica)----------------------------------------------------------------------------------
class MiHilo extends Thread {
    @Override
    public void run() {
        System.out.println("Hola desde un hilo");
    }
}

public class EjemploThread {
    public static void main(String[] args) {
        Thread hilo = new MiHilo();
        hilo.start(); // crea un hilo nuevo y ejecuta run()
    }
}

// 3.2. Runnable + Thread (forma recomendada sin resultado)-------------------------------------------------------------
class MiTarea implements Runnable {
    @Override
    public void run() {
        System.out.println("Tarea en segundo plano");
    }
}

public class EjemploRunnable {
    public static void main(String[] args) {
        Runnable tarea = new MiTarea();
        new Thread(tarea).start();
    }
}

// 3.3. Callable + Future (tarea con resultado)-------------------------------------------------------------------------
import java.util.concurrent.*;

class SumaCallable implements Callable<Integer> {
    @Override
    public Integer call() {
        int suma = 0;
        for (int i = 0; i < 100; i++) suma += i;
        return suma;
    }
}

public class EjemploCallable {
    public static void main(String[] args) throws Exception {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        Future<Integer> future = pool.submit(new SumaCallable());
        Integer resultado = future.get(); // espera y recoge el resultado
        System.out.println("Resultado = " + resultado);
        pool.shutdown();
    }
}

// 3.4. ExecutorService con Runnable (muchas tareas)--------------------------------------------------------------------
import java.util.concurrent.*;

public class EjemploExecutor {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService pool = Executors.newFixedThreadPool(4);

        for (int i = 0; i < 10; i++) {
            int id = i;
            pool.submit(() -> {
                System.out.println("Tarea " + id +
                    " en " + Thread.currentThread().getName());
            });
        }

        pool.shutdown();
        pool.awaitTermination(1, TimeUnit.MINUTES);
    }
}

4. MÃ‰TODOS COMUNES DE LA CLASE THREAD
------------------------------------------------------------------------------------------------------------------------
- start()
  - Arranca el hilo y llama internamente a run() en un hilo nuevo.
- run()
  - CÃ³digo que ejecutarÃ¡ el hilo (NO crea concurrencia si lo llamas directo).
- sleep(long ms)
  - Pausa el hilo actual durante ms milisegundos.
- join()
  - El hilo actual espera a que otro hilo termine.
- interrupt()
  - SeÃ±ala a un hilo para que se detenga de forma cooperativa.
- isInterrupted()
  - Comprueba si el hilo ha sido interrumpido.
- currentThread()
  - Devuelve una referencia al hilo que estÃ¡ ejecutando el cÃ³digo.
- setName(String) / getName()
  - Cambia / obtiene el nombre del hilo.
- setPriority(int)
  - Cambia la prioridad (se usa poco en cÃ³digo moderno).

5. CICLO DE VIDA DE LOS HILOS
------------------------------------------------------------------------------------------------------------------------
- NEW
  - new Thread(...) creado pero no iniciado.
- RUNNABLE
  - DespuÃ©s de start(), estÃ¡ listo para ejecutarse.
- RUNNING
  - El sistema operativo le da tiempo de CPU.
- BLOCKED / WAITING / TIMED_WAITING
  - Esperando un recurso, un bloqueo, sleep(), join(), etc.
- TERMINATED
  - El mÃ©todo run() ha terminado y el hilo muere.

6. PROBLEMAS TÃPICOS CON HILOS
------------------------------------------------------------------------------------------------------------------------
- Race conditions (condiciones de carrera)
  - Varios hilos modifican el mismo dato sin control.
  - Resultado depende del orden de ejecuciÃ³n â†’ resultados aleatorios.
- Inconsistencia de datos
  - Estados â€œimposiblesâ€ o incoherentes por accesos concurrentes mal gestionados.
- Deadlocks (interbloqueos)
  - Dos o mÃ¡s hilos se quedan esperando recursos entre sÃ­ y nadie avanza.
- Starvation
  - Un hilo nunca consigue CPU o recursos porque otros acaparan.
- Livelock
  - Los hilos cambian de estado continuamente, pero ninguno progresa.

7. SINCRONIZACIÃ“N
------------------------------------------------------------------------------------------------------------------------
- synchronized
  - En mÃ©todos:
        public synchronized void metodo() { ... }
  - En bloques:
        synchronized (candado) { ... }
  - Evita accesos simultÃ¡neos a secciones crÃ­ticas.
- volatile
  - Garantiza visibilidad de una variable entre hilos (lecturas/escrituras se ven).
  - No garantiza atomicidad por sÃ­ solo.
- Clases atÃ³micas (java.util.concurrent.atomic)
  - AtomicInteger, AtomicBoolean, etc.
  - Operaciones atÃ³micas sin bloquear todo el objeto.
- Locks (java.util.concurrent.locks)
  - ReentrantLock, ReadWriteLockâ€¦
  - MÃ¡s flexibles que synchronized (lock()/unlock()).
- wait(), notify(), notifyAll()
  - CoordinaciÃ³n de hilos sobre un mismo monitor (uso avanzado).

8. BUENAS PRÃCTICAS
------------------------------------------------------------------------------------------------------------------------
- Preferir ExecutorService y pools de hilos frente a crear muchos Thread a mano.
- Mantener las tareas simples y lo mÃ¡s independientes posible.
- Evitar compartir estado mutable; si es necesario, sincronizar claramente.
- Manejar correctamente las interrupciones (no ignorar InterruptedException).
- No abusar de sleep() como mecanismo de sincronizaciÃ³n.
- Documentar quÃ© cÃ³digo es â€œthread-safeâ€ y quÃ© no.
- Probar y depurar pensando en ejecuciÃ³n concurrente (errores pueden ser aleatorios).
*/
